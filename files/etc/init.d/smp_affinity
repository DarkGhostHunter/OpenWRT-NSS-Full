#!/bin/sh /etc/rc.common

START=99

# Helper function to set affinity
# $1: Mask (1=CPU0, 2=CPU1, 4=CPU2, 8=CPU3)
# $2: Name pattern to match in /proc/interrupts
set_affinity() {
    local mask="$1"
    local pattern="$2"
    
    # Grep for the pattern, ignore case (-i)
    # awk '{print $1}' gets the IRQ number (e.g., "43:")
    # tr -d ':' removes the colon
    for irq in $(grep -i "$pattern" /proc/interrupts | awk '{print $1}' | tr -d ':'); do
        if [ -d "/proc/irq/$irq" ]; then
            echo "Setting IRQ $irq ($pattern) to Mask $mask" > /dev/console
            echo "$mask" > "/proc/irq/$irq/smp_affinity"
        fi
    done
}

boot() {
    echo "Running NSS SMP Affinity optimization..." > /dev/console

    # --- STRATEGY ---
    # CPU0 (Mask 1): Reserved for OS, USB, and generic tasks. Keep network OFF this core.
    # CPU1 (Mask 2): Ethernet (EDMA) & Crypto
    # CPU2 (Mask 4): WiFi (REO/RxDMA)
    # CPU3 (Mask 8): NSS Queues (The heaviest load)

    # 1. Ethernet (EDMA) -> CPU1
    set_affinity 2 "edma"

    # 2. Crypto Engine (ce) -> CPU1
    set_affinity 2 "ce[0-9]"

    # 3. WiFi Receive Offload (REO/RxDMA) -> CPU2
    # These are the heavy lifters for WiFi RX
    set_affinity 4 "reo2host"
    set_affinity 4 "rxdma"
    set_affinity 4 "ppdu-end"

    # 4. NSS Queues -> CPU3
    # Your logs show nss_queue0 is HUGE (500k+ interrupts). 
    # We move these to the last core to keep them isolated.
    set_affinity 8 "nss_queue"
    set_affinity 8 "nss_empty"

    echo "NSS SMP Affinity applied." > /dev/console
}
