#!/bin/sh /etc/rc.common

START=99

# Helper function to set affinity
# $1: Mask (1=CPU0, 2=CPU1, 4=CPU2, 8=CPU3)
# $2: Name pattern to match in /proc/interrupts
set_affinity() {
    local mask="$1"
    local pattern="$2"
    
    # Grep for the pattern, ignore case (-i)
    # awk '{print $1}' gets the IRQ number (e.g., "43:")
    # tr -d ':' removes the colon
    for irq in $(grep -i "$pattern" /proc/interrupts | awk '{print $1}' | tr -d ':'); do
        if [ -d "/proc/irq/$irq" ]; then
            logger -p notice -t smp_affinity "Setting IRQ $irq ($pattern) to Mask $mask"
            echo "$mask" > "/proc/irq/$irq/smp_affinity"
        fi
    done
}

boot() {
    logger -p notice -t smp_affinity "Running NSS SMP Affinity optimization..."

    # --- STRATEGY ---
    # CPU0 (Mask 1): Reserved for OS, USB, and generic tasks. Network is OFF this core.
    # CPU1 (Mask 2): Ethernet (EDMA), Crypto & Secondary NSS Core
    # CPU2 (Mask 4): WiFi (REO/RxDMA)
    # CPU3 (Mask 8): Primary NSS Core (The heaviest load)

    # 1. Ethernet (EDMA) - Exception path only -> CPU1
    set_affinity 2 "edma"

    # 2. Crypto Engine (ce) -> CPU1
    set_affinity 2 "ce[0-9]"

    # 3. WiFi Receive Offload (REO/RxDMA) -> CPU2
    set_affinity 4 "reo2host"
    set_affinity 4 "rxdma"
    set_affinity 4 "ppdu-end"

    # 4. NSS Queues Dynamic Logic
    # Finds all nss_queue IRQs, sorts them numerically, and splits them in half.
    # First half (Core 0) -> CPU3
    # Second half (Core 1) -> CPU1
    logger -p notice -t smp_affinity "Applying Split NSS Affinity Strategy (Dynamic Count)..."

    # Get all NSS IRQs sorted numerically
    nss_irqs=$(grep -i "nss_queue" /proc/interrupts | awk '{print $1}' | tr -d ':' | sort -n)

    # Count how many we found
    total_count=$(echo "$nss_irqs" | wc -w)

    if [ "$total_count" -gt 0 ]; then
        # Calculate the split point (integer division)
        # e.g., if 8 queues, split_point is 4.
        split_point=$((total_count / 2))
        current_idx=0

        for irq in $nss_irqs; do
            current_idx=$((current_idx + 1))

            if [ -d "/proc/irq/$irq" ]; then
                if [ "$current_idx" -le "$split_point" ]; then
                    # First half goes to CPU3 (Mask 8)
                    echo "8" > "/proc/irq/$irq/smp_affinity"
                    logger -p notice -t smp_affinity "  - NSS Core 0 (IRQ $irq) -> CPU3"
                else
                    # Second half goes to CPU1 (Mask 2)
                    echo "2" > "/proc/irq/$irq/smp_affinity"
                    logger -p notice -t smp_affinity "  - NSS Core 1 (IRQ $irq) -> CPU1"
                fi
            fi
        done
    else
        logger -p warn -t smp_affinity "No NSS Queues found to optimize!"
    fi

    # 5. NSS Housekeeping (Buffer handling, etc) -> CPU3
    # Keeps the 'maintenance' work with the Primary Core
    set_affinity 8 "nss_empty"

    logger -p notice -t smp_affinity "NSS SMP Affinity applied successfully."
}