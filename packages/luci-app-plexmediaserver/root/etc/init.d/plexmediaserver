#!/bin/sh /etc/rc.common
# Copyright (C) 2024 OpenWrt.org

START=99
STOP=99
USE_PROCD=1

NAME=plexmediaserver

EXTRA_COMMANDS="setup_uci unpack_plex check_update update reset plex_umount reclaim is_installed check_browser_root"
EXTRA_HELP=$(cat <<EOF
        setup_uci       Does initial setup of UCI.
        unpack_plex     Unpacks the compresssed plexmediaserver archive if it exists.
        check_update    Checks if an updated Plex Media Server package is available for download.
        update          Downloads Plex Media Server and runs do_update to generate a compressed archive.
        reset           Wipes the plex media server config and re-generates it from scratch.
        plex_umount     Unmounts the Plex temporary mount points.
        reclaim         Recursively changes ownership of the Browser Root to the configured User/Group.
        is_installed    Returns 0 if Plex is properly installed (archive exists), 1 otherwise.
        check_browser_root Returns 0 if Browser Root exists and is a directory, 1 otherwise.
EOF
)

# Global variable for in-memory caching during script execution lifetime
JSON_CACHE_DATA=""

_info() {
	logger -p daemon.info -t "$NAME" "$*"
}

_err() {
	logger -p daemon.err -t "$NAME" "$*"
}

setup_uci() {
    [ -e /etc/config/plexmediaserver ] || touch /etc/config/plexmediaserver

    if ! uci -q get plexmediaserver.main >/dev/null; then
        uci set plexmediaserver.main=plexmediaserver
        uci commit plexmediaserver
    fi

    [ -z "$(uci -q get plexmediaserver.main.enabled)" ] && uci set plexmediaserver.main.enabled='1'

    for UCI_opt in browser_root library_dir tmp_dir application_support_dir compressed_archive_path version bin_dir claim_code force_version force_update_download_url run_user run_group; do
        if [ -z "$(uci -q get plexmediaserver.main.${UCI_opt})" ]; then
            uci set plexmediaserver.main.${UCI_opt}=''
        fi
    done

    config_load plexmediaserver
    config_get PLEX_LIBRARY_DIR main library_dir
    config_get PLEX_MEDIA_SERVER_APPLICATION_SUPPORT_DIR main application_support_dir
    config_get PLEX_COMPRESSED_ARCHIVE_PATH main compressed_archive_path
    config_get PLEX_TMP_DIR main tmp_dir
    config_get RUN_USER main run_user
    config_get RUN_GROUP main run_group

    # --- SAFE MODE: PASSIVE DETECTION ONLY ---
    if [ -n "$PLEX_LIBRARY_DIR" ] && [ ! -d "$PLEX_LIBRARY_DIR" ]; then
        _info "Configured library $PLEX_LIBRARY_DIR not found. Rescanning..."
        PLEX_LIBRARY_DIR=""
    fi

    if [ -z "$PLEX_LIBRARY_DIR" ]; then
        FOUND_LIB=$(find /mnt -maxdepth 4 -type d -path "*/.plex/Library" 2>/dev/null | head -n 1)

        if [ -n "$FOUND_LIB" ]; then
            PLEX_LIBRARY_DIR="$FOUND_LIB"
            PLEX_BROWSER_ROOT="${FOUND_LIB%/.plex/Library}"
            _info "Found Library: $PLEX_LIBRARY_DIR"
            uci set plexmediaserver.main.library_dir="$PLEX_LIBRARY_DIR"
            uci set plexmediaserver.main.browser_root="$PLEX_BROWSER_ROOT"
        fi
    fi

    if [ -z "$PLEX_MEDIA_SERVER_APPLICATION_SUPPORT_DIR" ] && [ -n "$PLEX_LIBRARY_DIR" ]; then
        PLEX_MEDIA_SERVER_APPLICATION_SUPPORT_DIR="${PLEX_LIBRARY_DIR}/Application Support"
        uci set plexmediaserver.main.application_support_dir="${PLEX_MEDIA_SERVER_APPLICATION_SUPPORT_DIR}"
    fi
    [ -n "$PLEX_MEDIA_SERVER_APPLICATION_SUPPORT_DIR" ] && [ ! -d "$PLEX_MEDIA_SERVER_APPLICATION_SUPPORT_DIR" ] && mkdir -p "$PLEX_MEDIA_SERVER_APPLICATION_SUPPORT_DIR"

    if [ -z "$PLEX_TMP_DIR" ]; then
        PLEX_TMP_DIR="/tmp/plexmediaserver"
        uci set plexmediaserver.main.tmp_dir="${PLEX_TMP_DIR}"
    fi
    mkdir -p "${PLEX_TMP_DIR}"

    # Default to .sqfs if not set
    if [ -z "${PLEX_COMPRESSED_ARCHIVE_PATH}" ] && [ -n "$PLEX_LIBRARY_DIR" ]; then
        PLEX_COMPRESSED_ARCHIVE_PATH="${PLEX_LIBRARY_DIR}/Application/plexmediaserver.sqfs"
        uci set plexmediaserver.main.compressed_archive_path="${PLEX_COMPRESSED_ARCHIVE_PATH}"
    fi

    if [ -n "$RUN_USER" ] && [ "$RUN_USER" != "0" ] && [ "$RUN_USER" != "root" ]; then
        chown "$RUN_USER:$RUN_GROUP" "$PLEX_TMP_DIR" 2>/dev/null
    fi

    uci commit plexmediaserver
}

is_installed() {
    config_load plexmediaserver
    config_get PLEX_COMPRESSED_ARCHIVE_PATH main compressed_archive_path

    # Check if the configured archive path exists
    if [ -n "$PLEX_COMPRESSED_ARCHIVE_PATH" ] && [ -f "$PLEX_COMPRESSED_ARCHIVE_PATH" ]; then
        return 0
    else
        return 1
    fi
}

check_browser_root() {
    config_load plexmediaserver
    config_get BROWSER_ROOT main browser_root

    if [ -n "$BROWSER_ROOT" ] && [ -d "$BROWSER_ROOT" ]; then
        return 0
    else
        return 1
    fi
}

unpack_plex() {
    setup_uci

    config_load plexmediaserver
    config_get PLEX_BIN_DIR main bin_dir
    config_get PLEX_VERSION main version
    config_get PLEX_COMPRESSED_ARCHIVE_PATH main compressed_archive_path
    config_get PLEX_TMP_DIR main tmp_dir
    config_get PLEX_FORCE_VERSION main force_version
    config_get RUN_USER main run_user
    config_get RUN_GROUP main run_group

    if [ -z "$PLEX_COMPRESSED_ARCHIVE_PATH" ] || [ ! -f "$PLEX_COMPRESSED_ARCHIVE_PATH" ]; then
        return 1
    fi

    if [ -n "${PLEX_BIN_DIR}" ] && [ -n "${PLEX_VERSION}" ] && [ -f "${PLEX_BIN_DIR}/Plex Media Server" ]; then
        return 0
    fi

    _info "Mounting Plex Media Server SquashFS..."

    # Copy SQFS to temp
    cp "${PLEX_COMPRESSED_ARCHIVE_PATH}" "${PLEX_TMP_DIR}"
    sleep 1

    # Mount
    mount -t squashfs -o ro,relatime "${PLEX_TMP_DIR}/$(basename "${PLEX_COMPRESSED_ARCHIVE_PATH}")" "${PLEX_TMP_DIR}"
    sleep 1

    # Mount tmpfs overlays
    for nn in "${PLEX_TMP_DIR}"/*/tmp; do
        grep -F "$nn" </proc/mounts || mount -t tmpfs tmpfs "${nn}"
        if [ -n "$RUN_USER" ] && [ "$RUN_USER" != "0" ]; then
            chown "$RUN_USER:$RUN_GROUP" "${nn}"
        fi
    done

    if ls -1 "${PLEX_TMP_DIR}" | grep -qE '^[0-9]+\..*$'; then
        PLEX_VERSION="$(ls -1 "${PLEX_TMP_DIR}" | grep -E '^[0-9]+\..*$' | sort -Vr | head -n 1)"
        uci set plexmediaserver.main.version="${PLEX_VERSION}"
    fi

    if [ -n "${PLEX_FORCE_VERSION}" ] && [ -e "${PLEX_TMP_DIR}/${PLEX_FORCE_VERSION}" ]; then
        _info "Using forced version: ${PLEX_FORCE_VERSION}"
        PLEX_VERSION="${PLEX_FORCE_VERSION}"
        uci set plexmediaserver.main.version="${PLEX_FORCE_VERSION}"
    fi

    config_get PLEX_VERSION main version
    PLEX_BIN_DIR="${PLEX_TMP_DIR}/${PLEX_VERSION}"
    uci set plexmediaserver.main.bin_dir="${PLEX_BIN_DIR}"

    uci commit plexmediaserver
}

plex_umount() {
    config_load plexmediaserver
    config_get PLEX_BIN_DIR main bin_dir
    config_get PLEX_TMP_DIR main tmp_dir

    if grep plexmediaserver </proc/mounts | grep -q squashfs; then
        _info "Unmounting Plex..."
        [ -n "$PLEX_BIN_DIR" ] && umount "${PLEX_BIN_DIR}/tmp" 2>/dev/null
        [ -n "$PLEX_TMP_DIR" ] && umount "${PLEX_TMP_DIR}" 2>/dev/null
    fi
}

reclaim() {
    config_load plexmediaserver
    config_get BROWSER_ROOT main browser_root
    config_get RUN_USER main run_user
    config_get RUN_GROUP main run_group

    if [ -z "$BROWSER_ROOT" ] || [ ! -d "$BROWSER_ROOT" ]; then
        _err "Cannot reclaim: Browser Root not defined or does not exist."
        return 1
    fi

    [ -z "$RUN_USER" ] && RUN_USER=0
    [ -z "$RUN_GROUP" ] && RUN_GROUP=0

    _info "Reclaiming ownership of $BROWSER_ROOT for User:$RUN_USER Group:$RUN_GROUP..."
    chown -R "$RUN_USER:$RUN_GROUP" "$BROWSER_ROOT"
    _info "Reclaim complete."
}

start_service() {
    config_load plexmediaserver
    config_get_bool enabled main enabled 1
    [ "$enabled" -eq 1 ] || return 0

    # Use check function
    if ! is_installed; then
        _info "Plex Media Server archive not found. Please download it using the 'Update' function first."
        return 0
    fi

    if ! unpack_plex; then
        _err "Failed to unpack/mount Plex."
        return 0
    fi

    config_load plexmediaserver
    config_get PLEX_BIN_DIR main bin_dir
    config_get PLEX_TMP_DIR main tmp_dir
    config_get PLEX_LIBRARY_DIR main library_dir
    config_get PLEX_BROWSER_ROOT main browser_root
    config_get PLEX_VERSION main version
    config_get PLEX_MEDIA_SERVER_APPLICATION_SUPPORT_DIR main application_support_dir
    config_get PLEX_CLAIM_CODE main claim_code
    config_get RUN_USER main run_user
    config_get RUN_GROUP main run_group

    if [ ! -x "${PLEX_BIN_DIR}/Plex Media Server" ]; then
        _err "Plex binary missing at ${PLEX_BIN_DIR}. Cannot start."
        return 0
    fi

    local vendor device model platform
    vendor="$(grep "id": /etc/board.json | awk -F:\  '{print $2}' | tr -d \" | awk -F, '{print $1}')"
    device="$(grep "id": /etc/board.json | awk -F:\  '{print $2}' | tr -d \" | awk -F, '{print $2}')"
    model="$(uname -m)"
    platform="$(grep ^NAME= /etc/os-release | awk -F= '{print $2}' | tr -d \")"
    local lan_ip="$(ip addr show br-lan 2>/dev/null | grep 'inet ' | sed -E s/'^.*inet (.*)\/.*$'/'\1'/ | head -n1)"

    _info "Starting Plex Media Server..."
    _info "URL: http://${lan_ip:-<ROUTER_IP>}:32400/web"

    procd_open_instance

    if [ -n "$RUN_USER" ] && [ "$RUN_USER" != "0" ]; then
        procd_set_param user "$RUN_USER"
        [ -n "$RUN_GROUP" ] && procd_set_param group "$RUN_GROUP"
    fi

    procd_set_param command /bin/sh
    procd_append_param command -c "cd '${PLEX_BIN_DIR}' && exec './Plex Media Server'"

    procd_set_param env PLEX_MEDIA_SERVER_HOME="${PLEX_BIN_DIR}"
    procd_set_param env PLEX_MEDIA_SERVER_MAX_PLUGIN_PROCS=6
    procd_set_param env PLEX_MEDIA_SERVER_DISABLE_AUTOUPDATES=1
    procd_set_param env PLEX_MEDIA_SERVER_DEFAULT_PREFERENCES="ScannerLowPriority=true&DlnaEnabled=false&TranscoderVideoResolutionLimit=1280x720&TranscoderH264Preset=ultrafast"
    procd_set_param env LC_ALL="C"
    procd_set_param env LANG="C"
    procd_set_param env TMPDIR="${PLEX_BIN_DIR}/tmp"
    procd_set_param env PLEX_BIN_DIR="${PLEX_BIN_DIR}"
    procd_set_param env PLEX_TMP_DIR="${PLEX_TMP_DIR}"
    procd_set_param env PLEX_LIBRARY_DIR="${PLEX_LIBRARY_DIR}"
    procd_set_param env PLEX_VERSION="${PLEX_VERSION}"
    procd_set_param env PLEX_BROWSER_ROOT="${PLEX_BROWSER_ROOT}"
    procd_set_param env PLEX_MEDIA_SERVER_APPLICATION_SUPPORT_DIR="${PLEX_MEDIA_SERVER_APPLICATION_SUPPORT_DIR}"
    procd_set_param env LD_LIBRARY_PATH="${PLEX_BIN_DIR}:${PLEX_BIN_DIR}/lib:/usr/lib"
    procd_set_param env PLEX_MEDIA_SERVER_INFO_VENDOR="$vendor"
    procd_set_param env PLEX_MEDIA_SERVER_INFO_DEVICE="$device"
    procd_set_param env PLEX_MEDIA_SERVER_INFO_MODEL="$model"
    procd_set_param env PLEX_MEDIA_SERVER_INFO_PLATFORM_VERSION="$platform"
    [ -n "${PLEX_CLAIM_CODE}" ] && procd_set_param env PLEX_CLAIM="${PLEX_CLAIM_CODE}"

    procd_set_param respawn
    procd_set_param stdout 1
    procd_set_param stderr 1
    procd_close_instance
}

service_triggers() {
    procd_add_reload_trigger "plexmediaserver"
}

check_update() {
    [ "$1" != "-n" ] && setup_uci
    config_load plexmediaserver

    config_get PLEX_VERSION main version
    config_get force_url main force_update_download_url

    # FIX: Make plex_url global (remove local) so do_update can access it
    plex_url=""
    local remote_version=""

    if [ -n "$force_url" ]; then
        _info "Using forced update URL: $force_url"
        plex_url="$force_url"
        # Can't compare version easily with custom URL, assume update needed if binary missing
    else
        if ! command -v jq >/dev/null 2>&1; then
            _err "Error: 'jq' utility is required for update check but not installed."
            return 1
        fi

        # Detect Architecture
        local is_64bit=0
        if [ "$(uname -m)" = "aarch64" ] || grep -q 'arm64' /proc/kallsyms 2>/dev/null; then
            is_64bit=1
        fi

        # MEMORY CACHE LOGIC
        if [ -n "$JSON_CACHE_DATA" ]; then
            _info "Using in-memory cached update information."
        else
            JSON_CACHE_DATA="$(curl -s https://plex.tv/api/downloads/5.json)"

            if [ -z "$JSON_CACHE_DATA" ]; then
                _err "Failed to download update information from plex.tv"
                return 1
            fi
        fi

        # EXTRACT VERSION AND URL using jq
        remote_version=$(echo "$JSON_CACHE_DATA" | jq -r '.nas.ASUSTOR.version // empty')

        if [ -n "$PLEX_VERSION" ] && [ -n "$remote_version" ] && [ "$PLEX_VERSION" = "$remote_version" ]; then
            _info "Plex is up to date (Version: $PLEX_VERSION)."
            plex_update_available=false
            return 0
        fi

        # Retrieve URL
        if [ "$is_64bit" -eq 1 ]; then
            plex_url="$(echo "$JSON_CACHE_DATA" | jq -r 'first([.nas.ASUSTOR.releases[] | select(.label=="ARMv8" or .label=="ARMv7").url][])')"
        else
            plex_url="$(echo "$JSON_CACHE_DATA" | jq -r 'first([.nas.ASUSTOR.releases[] | select(.label=="ARMv7").url][])')"
        fi
    fi

    if [ -z "$plex_url" ] || [ "$plex_url" = "null" ]; then
        _err "Could not resolve download URL."
        plex_update_available=false
        return 1
    fi

    _info "Update available (Remote: ${remote_version:-Unknown}, Local: ${PLEX_VERSION:-None})."
    plex_update_available=true
    return 0
}

update() {
    check_update
    if [ "$plex_update_available" = "true" ] || [ "$1" = "-f" ]; then
        do_update
    fi
}

do_update() {
    _info "=== Starting Plex Media Server Update ==="
    setup_uci
    config_load plexmediaserver
    config_get PLEX_COMPRESSED_ARCHIVE_PATH main compressed_archive_path

    # 1. URL Check
    if [ -z "$plex_url" ]; then
        _info "Update URL not set. running check_update..."
        check_update -n
    fi

    if [ -z "$plex_url" ]; then
        _err "CRITICAL: Download URL could not be resolved. Aborting."
        return 1
    fi
    _info "Update URL resolved: $plex_url"

    # 2. Workspace Setup
    local plex_tmp
    if [ -n "$PLEX_COMPRESSED_ARCHIVE_PATH" ]; then
        plex_tmp="$(dirname "$PLEX_COMPRESSED_ARCHIVE_PATH")"
    else
        plex_tmp="/tmp/plex_tmp"
    fi

    local kk=0
    while [ -e "${plex_tmp}/update_${kk}" ]; do kk=$((kk + 1)); done
    local work_dir="${plex_tmp}/update_${kk}"

    _info "Creating workspace at: $work_dir"
    mkdir -p "$work_dir" || { _err "Failed to create workspace."; return 1; }

    trap 'rm -rf "$work_dir"; _info "Workspace cleaned up."' EXIT

    cd "$work_dir" || { _err "Could not cd to workspace."; return 1; }

    # 3. Download
    local plex_filename
    plex_filename="$(echo "$plex_url" | sed -E 's|^.*/||' | sed -E 's/\?.*$//' | sed -E 's/\.apk$//')"

    _info "Downloading package: $plex_filename.apk ..."
    if wget -qO "${plex_filename}.apk" "$plex_url"; then
        _info "Download completed successfully."
    else
        _err "Download failed. Check internet connection or URL."
        return 1
    fi

    # 4. Extraction
    _info "Renaming .apk to .zip..."
    mv "${plex_filename}.apk" "${plex_filename}.zip"

    _info "Unzipping package..."
    if unzip -q "${plex_filename}.zip"; then
        _info "Unzip successful."
    else
        _err "Unzip failed. Corrupt download?"
        return 1
    fi

    # 5. Locate Payload
    if [ ! -f "data.tar.gz" ]; then
        _err "CRITICAL: data.tar.gz not found in the downloaded package structure."
        return 1
    fi

    local plex_ver
    plex_ver="$(echo "${plex_filename}" | sed -E s/'^.*PlexMediaServer\-'//)"
    _info "Identified Plex Version: $plex_ver"

    local extract_dir="${work_dir}/extracted"
    mkdir -p "$extract_dir"

    _info "Extracting inner data.tar.gz to $extract_dir ..."
    mv data.tar.gz "$extract_dir/"
    cd "$extract_dir" || return 1

    if gzip -dc "data.tar.gz" | tar -x; then
        _info "Inner tarball extracted successfully."
        rm "data.tar.gz" # Save space immediately
    else
        _err "Failed to extract data.tar.gz"
        return 1
    fi

    # 6. Backup Old Archive
    _info "Checking for existing archive to backup..."
    local old_archive_base="${plex_tmp}/plexmediaserver"

    if [ -f "${old_archive_base}.sqfs" ]; then
        _info "Backing up .sqfs -> .sqfs.old"
        mv -f "${old_archive_base}.sqfs" "${old_archive_base}.sqfs.old"
    fi

    # 7. Repackaging (SquashFS Only)
    mkdir -p "tmp"

    _info "Repackaging as .sqfs (SquashFS)..."

    if ! command -v mksquashfs >/dev/null; then
        _err "CRITICAL: mksquashfs not found! Cannot create archive."
        return 1
    fi

    rm -f "${plex_tmp}/plexmediaserver.sqfs"

    # Create SquashFS
    if mksquashfs . "${plex_tmp}/plexmediaserver.sqfs" -all-root -noappend -comp xz -Xdict-size 100%; then
        _info "Successfully created plexmediaserver.sqfs"
    else
        _err "Failed to create .sqfs archive!"
        return 1
    fi

    # 8. Completion
    mkdir -p "${plex_tmp}/old"
    mv "${plex_tmp}/plexmediaserver.sqfs.old" "${plex_tmp}/old/" 2>/dev/null

    _info "Update logic finished successfully."
    _info "Restarting Plex Media Server service..."
    /etc/init.d/plexmediaserver restart
}

reset() {
    /etc/init.d/plexmediaserver stop
    rm -f /etc/config/plexmediaserver
    setup_uci
    update -f
    /etc/init.d/plexmediaserver start
}