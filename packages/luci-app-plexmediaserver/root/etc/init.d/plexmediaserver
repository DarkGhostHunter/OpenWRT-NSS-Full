#!/bin/sh /etc/rc.common
# Copyright (C) 2024 OpenWrt.org

START=99
STOP=99
USE_PROCD=1

NAME=plexmediaserver

# Default configuration values
DEFAULT_BROWSER_ROOT="/mnt/sda1/Media"
DEFAULT_LIBRARY_DIR="/mnt/sda1/Media/.plex/Library"
DEFAULT_SUPPORT_DIR="/mnt/sda1/Media/.plex/Library/Application Support"
DEFAULT_ARCHIVE_PATH="/mnt/sda1/Media/.plex/Library/Application/plexmediaserver.sqfs"
# tmp_dir is now derived relative to library_dir in start_service
DEFAULT_BIN_DIR="/usr/lib/plexmediaserver"

EXTRA_COMMANDS="check_update update check_browser_root"
EXTRA_HELP=$(cat <<EOF
        check_update    Checks if an updated Plex Media Server package is available.
        update          Downloads and repackages Plex Media Server.
        check_browser_root Checks if Browser Root exists.
EOF
)

_info() {
    logger -p daemon.info -t "$NAME" "$*"
}

_err() {
    logger -p daemon.err -t "$NAME" "$*"
}

# Clean path helper to remove trailing slashes
clean_path() {
    echo "$1" | sed 's:/*$::'
}

cleanup_mount() {
    local mount_point="$1"

    if mountpoint -q "$mount_point"; then
        _info "Unmounting $mount_point..."
        # Sync to flush writes before unmount attempt
        sync

        # Try normal unmount, then lazy unmount if busy to prevent boot locks
        umount "$mount_point" || {
            _err "Standard unmount failed. Attempting lazy unmount..."
            umount -l "$mount_point" || {
                _err "Failed to unmount $mount_point."
                return 1
            }
        }
    fi
    return 0
}

start_service() {
    config_load plexmediaserver

    local enabled browser_root library_dir application_support_dir compressed_archive_path tmp_dir bin_dir

    config_get_bool enabled main enabled 1
    config_get browser_root main browser_root "$DEFAULT_BROWSER_ROOT"
    config_get library_dir main library_dir "$DEFAULT_LIBRARY_DIR"

    # 2. Fix: Derive tmp_dir relative to library_dir to avoid RAM exhaustion
    config_get tmp_dir main tmp_dir "${library_dir}/tmp"

    config_get application_support_dir main application_support_dir "$DEFAULT_SUPPORT_DIR"
    config_get compressed_archive_path main compressed_archive_path "$DEFAULT_ARCHIVE_PATH"
    config_get bin_dir main bin_dir "$DEFAULT_BIN_DIR"

    # Sanitize paths
    bin_dir=$(clean_path "$bin_dir")
    library_dir=$(clean_path "$library_dir")

    [ "$enabled" -eq 1 ] || return 0

    if [ ! -f "$compressed_archive_path" ]; then
        _err "Archive not found at: $compressed_archive_path"
        return 1
    fi

    if [ ! -d "$browser_root" ]; then
        _err "Browser root not found at: $browser_root"
        return 1
    fi

    # Prepare Directories
    mkdir -p "$bin_dir" "$library_dir" "$application_support_dir" "$tmp_dir"

    # 1. Fix: Idempotency check. Only mount if not already mounted.
    if ! mountpoint -q "$bin_dir"; then
        _info "Mounting $compressed_archive_path to $bin_dir"
        # Mount directly from HDD to fixed path. ro=read-only, loop=loopback device
        mount -t squashfs -o loop,ro "$compressed_archive_path" "$bin_dir"
        if [ $? -ne 0 ]; then
            _err "Failed to mount Plex archive."
            return 1
        fi
    else
        _info "$bin_dir is already mounted. Skipping mount."
    fi

    procd_open_instance

    # 7. Fix: Smart HOME Detection (Nesting Prevention)
    # If library_dir ends in "/Library", we use the parent as HOME.
    # If library_dir does NOT end in "/Library" (e.g. ".../.plex"), we use it AS the HOME.
    # This ensures Plex always writes to ".../.plex/Library" regardless of which path style the user chose.
    local plex_home
    case "$library_dir" in
        */Library)
            plex_home="$(dirname "$library_dir")"
            ;;
        *)
            plex_home="$library_dir"
            ;;
    esac

    # 10. Fix: Priority Management (Nice Level)
    # Replaced taskset (pinning) with process priority management.
    # 'nice 19' tells the kernel this is the lowest priority process.
    # It will use ALL cores (0-3) when they are idle, but yield immediately
    # if WiFi (CPU2), NSS (CPU3), or System (CPU0/1) need resources.
    procd_set_param nice 19
    procd_set_param command /usr/bin/env HOME="$plex_home" "$bin_dir/Plex Media Server"

    # 6. Fix: Set Working Directory to Library Dir
    procd_set_param workdir "$library_dir"

    # Environment Variables
    procd_set_param env PLEX_MEDIA_SERVER_HOME="$bin_dir"
    procd_set_param env PLEX_MEDIA_SERVER_APPLICATION_SUPPORT_DIR="$application_support_dir"
    procd_set_param env PLEX_MEDIA_SERVER_MAX_PLUGIN_PROCS=6
    procd_set_param env PLEX_MEDIA_SERVER_TMPDIR="$tmp_dir"
    # 5. Fix: Expanded LD_LIBRARY_PATH to include 'lib' subdirectory
    procd_set_param env LD_LIBRARY_PATH="$bin_dir:$bin_dir/lib"
    procd_set_param env LC_ALL="en_US.UTF-8"
    procd_set_param env LANG="en_US.UTF-8"

    # Limits - Disable core dumps to save space
    procd_set_param limits core="0"

    # Auto-restart settings
    procd_set_param respawn ${respawn_threshold:-3600} ${respawn_timeout:-5} ${respawn_retry:-5}

    procd_set_param stdout 1
    procd_set_param stderr 1
    procd_close_instance
}

stop_service() {
    config_load plexmediaserver
    local bin_dir
    config_get bin_dir main bin_dir "$DEFAULT_BIN_DIR"
    bin_dir=$(clean_path "$bin_dir")

    # 3. Fix: Enhanced Race condition handling.
    local i=0
    local timeout=15

    _info "Waiting for Plex Media Server to exit..."

    # Loop checks for Main process AND common children
    while (pidof "Plex Media Server" >/dev/null || pidof "Plex Script Host" >/dev/null) && [ $i -lt $timeout ]; do
        sleep 1
        i=$((i+1))
    done

    # CRITICAL FIX: Only attempt aggressive kills if the directory is ACTUALLY a mount point.
    # Running fuser -m on a standard directory targets the root filesystem, causing system crashes.
    if mountpoint -q "$bin_dir"; then

        # 8. Fix: Force Kill if stuck (Only if mounted)
        if pidof "Plex Media Server" >/dev/null || pidof "Plex Script Host" >/dev/null; then
            _err "Plex did not exit gracefully. Force killing..."
            killall -9 "Plex Media Server" 2>/dev/null
            killall -9 "Plex Script Host" 2>/dev/null
            killall -9 "Plex Tuner Service" 2>/dev/null
            sleep 2
        fi

        # 9. Fix: Fuser check to ensure mount is free
        # Redirect output to /dev/null to keep logs clean
        if command -v fuser >/dev/null; then
            if fuser -m "$bin_dir" >/dev/null 2>&1; then
                _err "Mount still busy. Killing processes using $bin_dir..."
                fuser -k -9 -m "$bin_dir" >/dev/null 2>&1
                sleep 1
            fi
        fi

        # Finally unmount
        cleanup_mount "$bin_dir"
    fi
}

service_triggers() {
    procd_add_reload_trigger "plexmediaserver"
}

check_browser_root() {
    config_load plexmediaserver
    local browser_root
    config_get browser_root main browser_root "$DEFAULT_BROWSER_ROOT"

    if [ -d "$browser_root" ]; then
        echo "Browser Root exists: $browser_root"
        return 0
    else
        echo "Browser Root missing: $browser_root"
        return 1
    fi
}

# New helper function to get URL without global variables
get_plex_url() {
    local force_url
    config_load plexmediaserver
    config_get force_url main force_update_download_url

    if [ -n "$force_url" ]; then
        echo "$force_url"
        return 0
    fi

    if ! command -v jq >/dev/null 2>&1; then
        _err "jq is required but missing."
        return 1
    fi

    # Cache handling
    local json_data
    if [ -n "$JSON_CACHE_DATA" ]; then
        json_data="$JSON_CACHE_DATA"
    else
        # Added timeout to prevent hangs
        json_data="$(curl --max-time 15 -s https://plex.tv/api/downloads/5.json)"
    fi

    if [ -z "$json_data" ]; then
        return 1
    fi

    # Architecture Detection
    local arch_label="ARMv7"
    if [ "$(uname -m)" = "aarch64" ] || grep -q 'arm64' /proc/kallsyms 2>/dev/null; then
        arch_label="ARMv8"
    fi

    # Extract URL based on Architecture
    local url
    url="$(echo "$json_data" | jq -r --arg label "$arch_label" 'first([.nas.ASUSTOR.releases[] | select(.label==$label).url][])')"

    if [ -z "$url" ] || [ "$url" = "null" ]; then
        return 1
    fi

    echo "$url"
    return 0
}

check_update() {
    config_load plexmediaserver
    local current_version
    config_get current_version main version

    # Just grab the version from JSON for comparison
    local json_data remote_version
    json_data="$(curl --max-time 15 -s https://plex.tv/api/downloads/5.json)"
    remote_version=$(echo "$json_data" | jq -r '.nas.ASUSTOR.version // empty')

    if [ -z "$remote_version" ]; then
        _err "Could not retrieve remote version."
        return 1
    fi

    if [ "$current_version" = "$remote_version" ]; then
        _info "Plex is up to date ($current_version)."
        return 0
    else
        _info "Update available: $remote_version (Current: $current_version)"
        return 0
    fi
}

update() {
    local force=0
    [ "$1" = "-f" ] && force=1

    config_load plexmediaserver
    local current_version
    config_get current_version main version

    # We fetch the URL immediately. If this fails, we stop.
    local plex_url
    plex_url=$(get_plex_url)

    if [ -z "$plex_url" ]; then
        _err "Could not determine download URL."
        return 1
    fi

    # Simple version check if not forced
    if [ "$force" -eq 0 ]; then
        local remote_file=$(basename "$plex_url")
        local archive_path
        config_get archive_path main compressed_archive_path "$DEFAULT_ARCHIVE_PATH"

        # FIX: First Run Detection
        # If the archive doesn't exist, we MUST update/download regardless of version
        if [ ! -f "$archive_path" ]; then
             _info "Archive missing. Assuming first run and proceeding with download..."

        # If archive exists, we safely check version match
        elif [ -n "$current_version" ]; then
             # Loose check: if the URL filename contains the current version, skip
             if echo "$remote_file" | grep -q "$current_version"; then
                  _info "Version in URL matches current config version. Use -f to force."
                  return 0
             fi
        fi
    fi

    do_update_process "$plex_url"
}

do_update_process() {
    local url="$1"

    config_load plexmediaserver
    local archive_path
    config_get archive_path main compressed_archive_path "$DEFAULT_ARCHIVE_PATH"

    local plex_tmp
    plex_tmp="$(dirname "$archive_path")"

    # 4. Fix: Disk Space Check. Ensure we have ~500MB free before starting.
    # We MUST ensure the directory exists first, or df will fail.
    if [ ! -d "$plex_tmp" ]; then
        mkdir -p "$plex_tmp"
    fi

    # 'df' output column 4 is usually 'Available' blocks (1K blocks)
    # tail -n 1 handles potential line wrapping in output
    local available_kbytes
    available_kbytes=$(df -k "$plex_tmp" | tail -n 1 | awk '{print $4}')

    if [ -z "$available_kbytes" ] || [ "$available_kbytes" -lt 500000 ]; then
        _err "Insufficient disk space in $plex_tmp. Need ~500MB."
        return 1
    fi

    # Workspace Setup
    local work_dir="${plex_tmp}/update_temp_$$"
    mkdir -p "$work_dir" || { _err "Failed to create workspace"; return 1; }

    # Trap to ensure cleanup happens even if script is killed
    trap 'rm -rf "$work_dir"; _info "Workspace cleaned up."' EXIT

    cd "$work_dir" || return 1

    _info "Downloading Plex..."
    if ! wget -qT 30 -O "package.apk" "$url"; then
        _err "Download failed."
        return 1
    fi

    _info "Extracting..."
    # Piping unzip to /dev/null to reduce log noise, checking exit code
    unzip -q "package.apk" || { _err "Unzip failed"; return 1; }

    if [ ! -f "data.tar.gz" ]; then
        _err "Invalid package: data.tar.gz missing"
        return 1
    fi

    mkdir extracted
    # Use pipefail to catch gzip errors
    set -o pipefail
    if ! gzip -dc "data.tar.gz" | tar -xC extracted; then
        _err "Failed to extract data.tar.gz"
        return 1
    fi
    set +o pipefail

    # CRITICAL CHANGE: Stop service BEFORE mksquashfs
    # Repacking is CPU intensive. We need the resources.
    _info "Stopping Plex service for repackaging..."
    /etc/init.d/plexmediaserver stop

    # Verify we have tools
    if ! command -v mksquashfs >/dev/null; then
        _err "mksquashfs missing."
        return 1
    fi

    local new_archive="${plex_tmp}/plexmediaserver.sqfs.new"
    rm -f "$new_archive"

    _info "Creating SquashFS archive (this may take time)..."
    cd extracted
    # OPTIMIZATION: LZ4 with High Compression
    # -comp lz4: Fastest decompression, perfect for ARMv8/NEON.
    # -Xhc: High Compression mode. Takes longer to build (CPU intensive) but yields
    #       smaller archives without slowing down reads. Good for reducing disk usage.
    # -b 256k: Good balance for performance.
    if mksquashfs . "$new_archive" -all-root -noappend -comp lz4 -Xhc -b 256k; then
        _info "Archive created successfully."

        # Rotate files
        if [ -f "$archive_path" ]; then
            mv "$archive_path" "${archive_path}.old"
        fi
        mv "$new_archive" "$archive_path"

        _info "Update complete. Restarting service..."
        /etc/init.d/plexmediaserver start
    else
        _err "Failed to create archive. Reverting..."
        /etc/init.d/plexmediaserver start
        return 1
    fi
}

reset() {
    _info "Resetting Plex configuration..."
    /etc/init.d/plexmediaserver stop
    rm -f /etc/config/plexmediaserver
    # Note: reset assumes the update command will fetch the config/binary again
    # But update requires config to know where to put things.
    # This circular dependency suggests reset might fail if defaults aren't enough.
    # We strictly shouldn't delete the UCI config if update relies on it.
    _err "Reset performed. You may need to re-configure paths."
}